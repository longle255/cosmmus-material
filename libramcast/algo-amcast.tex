%!TEX root =  main.tex

\newcommand{\rdwrite}[3]{\textsf{write}\ensuremath{(#1, #2, #3)}}	% rdwrite(addr,val) 
\newcommand{\band}{\textbf{and}}
\newcommand{\mcast}{\textsc{mcast}}
\newcommand{\ordered}{\textsc{ordered}}
\newcommand{\done}{\textsc{done}}

\begin{algorithm}
\footnotesize

\begin{distribalgo}[1]

\STATE{Each server has a shared buffer $M$, with multicast messages, and a protected buffer $T$, with message timestamps, per client $c$}	
\vspace{1.0mm}
\INDENT{Each entry $M[c,i]$ contains the following information:}
	\STATE $msg$: the message $m$ multicast by client $c$
	\STATE $tmp$: the timestamp of $m$, initially $(0,0)$
	\STATE $dst$: destination groups $m$ is addressed to
	\STATE $ptr[p]$: position of $m$ in the buffer at $p$
	\STATE $ack[g]$: acknowledgement of timestamp in $tmp[g]$
	\STATE $stat$: state of $m$: $\perp$ (initially), \mcast, \ordered\ or \done
\ENDINDENT
\vspace{1.0mm}
\INDENT{Each entry $T[c,i]$ contains the following information:}
	\STATE $tmp[g]$: timestamp proposed by group $g$
	\STATE $rnd[g]$: round $g$'s leader, initially 0
\ENDINDENT
\vspace{1.0mm}
\STATE{Each client $c$ has structure $ptr[p]$ with the next available entry in $p$'s buffers $M[c,-]$ and $T[c,-]$}
\vspace{1.0mm}

\INDENT{Each server $p$ at group $g$ also has:}
	\STATE $clock$: logical timestamp counter at $p$, initially $(0,p)$
	\STATE $round$: the round of $p$, when leader, initially $(0,p)$
	\STATE $Leader[g]$ the leader at $g$ (as seen by $p$), initially 0
	\STATE $Round[g]$: last accepted round at $g$, initially 0
\ENDINDENT

\vspace{2.0mm}

\INDENT{\textbf{procedure} $Relay(c,msg,dst,ptr)$}
	\INDENT{for each $h$ in $dst$: for each $q$ in $h$}
		\STATE \rdwrite{q}{M[c,ptr[q]].msg}{msg}
		\STATE \rdwrite{q}{M[c,ptr[q]].dst}{dst}
		\STATE \rdwrite{q}{M[c,ptr[q]].ptr}{ptr}
		\STATE \rdwrite{q}{M[c,ptr[q]].stat}{\mcast}
	\ENDINDENT
\ENDINDENT
\vspace{2.0mm}
\INDENT{\textbf{procedure} $increment((cnt,pid))$}
	\STATE $cnt \leftarrow cnt + 1$
	\STATE return $(cnt,pid)$
\ENDINDENT
\vspace{2.0mm}

\vspace{2.0mm}
\INDENT{\textbf{procedure} $max((cnt_1,pid_1),(cnt_2,pid_2))$}
	\IF{$cnt_1 > cnt_2$ \textbf{or} $(cnt_1=cnt_2\ \band\ pid_1 > pid_2)$}
		\STATE return $(cnt_1,pid_1)$
	\ELSE
		\STATE return $(cnt_2,pid_2)$
	\ENDIF
\ENDINDENT
\vspace{2.0mm}


\caption{Data structures and procedures}
\label{alg:data_struct}
\end{distribalgo}
\end{algorithm}

\clearpage
\begin{algorithm}
\footnotesize

\begin{distribalgo}[1]

\STATE{Client $c$ multicasts message $m$ to groups in $m.dst$ as follows:}
\vspace{1.0mm}
	\INDENT[\textbf{Task 1}]{for each $h$ in $m.dst$, for each $q$ in $h$}
		\STATE $ptr[q] \leftarrow ptr[q] + 1$
	\ENDINDENT
	\STATE $Relay(c,msg,m.dst,ptr)$
%	\INDENT{for each $h$ in $dst$}
%		\STATE \rdwrite{q}{M[c,next[q]].msg}{m}
%		\STATE \rdwrite{q}{M[c,next[q]].dst}{m.dst}
%		\STATE \rdwrite{q}{M[c,next[q]].ptr}{next}
%		\STATE \rdwrite{q}{M[c,next[q]].tmp}{0}
%		\STATE \rdwrite{q}{M[c,next[q]].stat}{\mcast}
%	\ENDINDENT
\vspace{1.0mm}

\STATE Server $p$ in group $g$ executes as follows:
\vspace{1.0mm}
\WHEN[\textbf{Task 2}]{$\exists c,i:\!M[c,i].stat\!=\!\mcast$\ \band\ 
		$p\!=\!Leader[g]$\hspace{-2mm}}
	\STATE $clock \leftarrow increment(clock)$
	\INDENT{for each follower $q$ in $g$ \band\ each leader $q$ in $M[c,i].dst$}
		\STATE $j \leftarrow M[c,i].ptr[q]$
		\STATE \rdwrite{q}{T[c,j].tmp[g]}{clock}
		\STATE \rdwrite{q}{T[c,j].rnd[g]}{round}
		\STATE \textbf{if} write denied \textbf{then} end task
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 3}]{$\exists c, i\!:\!M[c,i].stat\!=\!\mcast$\ \band \\
		\hspace{14mm} $T[c,i].rnd[g] = Round[g]$}
	\STATE $clock \leftarrow max(clock,T[c,i].tmp[g])$
	\INDENT{for each $h$ in $M[c,i].dst$, for each $q$ in $h$}
		\STATE $j \leftarrow M[c,i].ptr[q]$
		\STATE \rdwrite{q}{M[c,j].ack[p]}{Round[g]}
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 4}]{$\exists c, i, h\!:\!M[c,i].stat =$ \mcast\ \band \\
		\hspace{14mm} $T[c,i].rnd[h] = Round[h]$ \band\ $h \neq g$ \hspace{-2mm}}
	\STATE $clock \leftarrow max(clock,T[c,i].tmp[g])$
	\INDENT{for each follower $q$ in $g$}
		\STATE{$j \leftarrow M[c,i].ptr[q]$}
		\STATE \rdwrite{q}{T[c,j].tmp[h]}{T[c,i].tmp[h]}
		\STATE \textbf{if} write denied \textbf{then} end task
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 5}]{$\exists c, i, h\!:\!M[c,i].stat =$ \mcast\ \band\ $\exists\!$ quorum $Q$ in $h$: \\
	\hspace{5mm} for each $q$ in $Q$: $M[c,i].ack[q] = Round[h]$}
			\STATE $M[c,i].tmp \leftarrow$ 
				 $max(M[c,i].tmp, T[c,i].tmp[h])$
			\IF{for each group $h$ in $M[c,i].dst$: $\exists\!$ quorum $Q$ in $h$: \\
	\hfill for each $q$ in $Q$: $M[c,i].ack[q] = Round[h]$}
						\STATE $M[c,i].stat \leftarrow$ \ordered
			\ENDIF
%			\STATE{include $(m,t_{final})$ in $ordered$}
%			\STATE{remove $(m,-,-)$ from $pending$}		
\ENDWHEN
\vspace{1.0mm}


\WHEN[\textbf{Task 6}]{$\exists c, i\!:\!M[c,i].stat =$ \ordered\ \band \\
	\hspace{10mm} $\nexists d,j\!:\!M[d,j].stat \in \{ \ordered, \mcast \}$ \band\ \\
	\hspace{10mm} $M[d,j].tmp < M[c,i].tmp$}
		\STATE{deliver $m$}
		\STATE $M[c,i].stat \leftarrow$ \done
\ENDWHEN
\vspace{1.0mm}

\caption{Normal case (no failures)}
\label{alg:normal_case}
\end{distribalgo}
\end{algorithm}
