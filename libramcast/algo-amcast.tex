%!TEX root =  main.tex

\newcommand{\rdwrite}[3]{WRITE\ensuremath{(@#1\!\rightarrow\!#2, #3)}}	% rdwrite(addr,val) 
%\newcommand{\rmm}[2]{\ensuremath{@#1\!\rightarrow\!#2}}
\newcommand{\band}{\textbf{and}}
\newcommand{\mcast}{\textsf{mcast}}
\newcommand{\ack}{\textsf{ack}}
\newcommand{\ordered}{\textsf{ordered}}
\newcommand{\done}{\textsf{done}}
\newcommand{\myack}{\textsf{ack}}

\begin{algorithm}
\footnotesize

\begin{distribalgo}[1]

\STATE{Each server has a shared buffer $M$ with multicast messages and a protected buffer $T$ with message timestamps per client $c$}	
\vspace{1.0mm}
\INDENT{Each entry $M[c,i]$ contains the following information:}
	\STATE $msg$: the message $m$ multicast by client $c$
	\STATE $tmp$: the timestamp of $m$, computed by the algorithm
	\STATE $dst$: destination groups $m$ is addressed to
	\STATE $slot[]$: buffer entry with message at each process
	\STATE $ack[p]$: acknowledgement of timestamp in $tmp[p]$
	\STATE $stat$: state of message $m$: \mcast, \ordered\ or \done
\ENDINDENT
\vspace{1.0mm}
\INDENT{Each entry $T[c,i]$ contains the following information:}
	\STATE $tmp[g]$: timestamp proposed by group $g$
	\STATE $rnd[g]$: round in which $g$'s leader proposed timestamp
\ENDINDENT
\vspace{1.0mm}
\STATE{Each client has structure $next[p]$ containing the next entry in the buffer at $p$}
\vspace{1.0mm}

\INDENT{Each server $p$ at group $g$ also has:}
	\STATE{$Leader[g]$ the identifier of the leader at $g$ (as seen by $p$)}
%	\INDENT{$round$: $p$'s current round in any execution}
%		\STATE{incremented when becomes leader}
%		\STATE{unique per process}
%	\ENDINDENT
	\STATE{$clock$: logical timestamp counter at process $p$}
\ENDINDENT
\vspace{1.0mm}
\caption{Data structures}
\label{alg:data_struct}
\end{distribalgo}
\end{algorithm}

\begin{algorithm}
\footnotesize

\begin{distribalgo}[1]

\STATE{Client $c$ multicasts message $m$ to groups in $dst$ as follows:}
\vspace{1.0mm}
	\STATE for each $h$ in $dst$: for each $q$ in $h$: increment $next[q]$
	\INDENT{for each $h$ in $dst$: for each $q$ in $h$}
		\STATE \rdwrite{q}{M[c,next[q]].msg}{m}
		\STATE \rdwrite{q}{M[c,next[q]].dst}{dst}
		\STATE \rdwrite{q}{M[c,next[q]].slot}{next}
		\STATE \rdwrite{q}{M[c,next[q]].tmp}{0}
		\STATE \rdwrite{q}{M[c,next[q]].stat}{\mcast}
	\ENDINDENT
\vspace{1.0mm}

\STATE Server $p$ in group $g$ executes as follows:
\vspace{1.0mm}
\WHEN[\textbf{Task 1}]{$\exists c,i:\!M[c,i].stat\!=\!\mcast$\ \band\ 
		$p\!=\!Leader[g]$\hspace{-2mm}}
	\STATE increment $clock$
	\INDENT{for each follower $q$ in $g$ \band\ each leader $q$ in $M[c,i].dst$}
		\STATE $j \leftarrow M[c,i].slot[q]$
		\STATE \rdwrite{q}{T[c,j].tmp[g]}{clock}
		\IF{write denied}
			\STATE request permission (Phase 1)
			\STATE end task
		\ENDIF
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 2}]{$\exists c, i\!:\!M[c,i].stat\!=\!\mcast$\ \band \\
		\hspace{14mm} $T[c,i].tmp[g]\!\neq\!0$\hspace{-2mm}}
	\STATE update $clock$ with $T[c,i].tmp[g]$
	\INDENT{for each $h$ in $M[c,i].dst$: for each $q$ in $h$}
		\STATE $j \leftarrow M[c,i].slot[q]$
		\STATE \rdwrite{q}{M[c,j].ack[p]}{\myack}
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 3}]{$\exists c, i, h\!:\!M[c,i].stat =$ \mcast\ \band \\
		\hspace{14mm} $T[c,i].tmp[h] \neq 0$ \band\ $h \neq g$ \hspace{-2mm}}
	\STATE update $clock$ with $T[c,i].tmp[g]$
	\INDENT{for each follower $q$ in $g$}
		\STATE{$j \leftarrow M[c,i].slot[q]$}
		\STATE \rdwrite{q}{T[c,j].tmp[h]}{T[c,i].tmp[h]}
		\INDENT{if write denied then}
			\STATE{request permission (Phase 1)}
			\STATE end task
		\ENDINDENT
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 4}]{$\exists c, i, h\!:\!M[c,i].stat =$ \mcast\ \band\ $\exists\!$ quorum $Q$ in $h$: \\
	\hspace{5mm} for each $q$ in $Q$: $M[c,i].ack[q] = \ack$}
			\STATE $M[c,i].tmp \leftarrow$ \\
				\hspace{10mm} $max\{ M[c,i].tmp, M[c,i].tmp[Leader[h]] \}$
			\IF{for each group $h$ in $M[c,i].dst$: $\exists\!$ quorum $Q$ in $h$: \\
	\hfill for each $q$ in $Q$: $M[c,i].ack[q] = \ack$}
						\STATE $M[c,i].stat \leftarrow$ \ordered
			\ENDIF
%			\STATE{include $(m,t_{final})$ in $ordered$}
%			\STATE{remove $(m,-,-)$ from $pending$}		
\ENDWHEN
\vspace{1.0mm}


\WHEN[\textbf{Task 5}]{$\exists c, i\!:\!M[c,i].stat =$ \ordered\ \band \\
	\hspace{10mm} $\nexists d,j\!:\!M[d,j].stat \in \{ \ordered, \mcast \}$ \band\ \\
	\hspace{10mm} $M[d,j].tmp < M[c,i].tmp$}
		\STATE{deliver $m$}
		\STATE $M[c,i].stat \leftarrow$ \done
\ENDWHEN
\vspace{1.0mm}

\caption{Algorithm}
\label{alg:normal_case}
\end{distribalgo}
\end{algorithm}
