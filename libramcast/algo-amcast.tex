%!TEX root =  main.tex


\begin{algorithm}
\footnotesize

\begin{distribalgo}[1]

\STATE{Each server contains a buffer $B[c]$ per client $c$}	
\vspace{1.0mm}
\INDENT{Each entry $B[c,i]$ contains the following information:}
	\STATE $msg$: the message $m$ multicast by client $c$
	\STATE $tmp$: the final timestamp of $m$, computed by the algorithm
	\STATE $Slot[]$: buffer entry with message at each process
	\STATE $tmp[p]$: proposed timestamp for $m$ by leader process $p$
	\STATE $rnd[p]$: round in which leader $p$ proposed timestamp
	\STATE $ack[p]$: acknowledgement of timestamp in $tmp[p]$
\ENDINDENT
\vspace{1.0mm}
\STATE{The structure $B[c]$ is shared between all servers and client $c$}
\vspace{1.0mm}
\STATE{Each client contains structure $Next[p]$ containing the next entry in the buffer at $p$}
\vspace{1.0mm}

\INDENT{Each server also $p$ contains:}
	\STATE{$Leader[g]$ with the identifier of the leader at $g$ (as seen by $p$)}
	\INDENT{$round$: $p$'s current round in any execution}
		\STATE{incremented when becomes leader}
		\STATE{unique per process}
	\ENDINDENT
	\STATE{$tmp$: logical timestamp counter at process $p$}
\ENDINDENT
\vspace{1.0mm}
\caption{Data structures}
\label{alg:data_struct}
\end{distribalgo}
\end{algorithm}

\newcommand{\rdwrite}[3]{WRITE\ensuremath{(@#1\!\rightarrow\!#2, #3)}}	% rdwrite(addr,val) 
%\newcommand{\rmm}[2]{\ensuremath{@#1\!\rightarrow\!#2}}
\newcommand{\band}{\textbf{and}}
\newcommand{\mcast}{\textsf{mcast}}
\newcommand{\ack}{\textsf{ack}}
\newcommand{\ordered}{\textsf{ordered}}
\newcommand{\done}{\textsf{done}}

\begin{algorithm}
\footnotesize

\begin{distribalgo}[1]

\STATE{Client $c$ multicasts message $m$ to groups in $dst$ as follows:}
\vspace{1.0mm}
%	\INDENT{for each $q$ in $m.dst$}
%		\STATE{increment $Next[q]$}
%	\ENDINDENT
	\STATE for each $h$ in $dst$: for each $q$ in $h$: increment $next[q]$
	\INDENT{for each $h$ in $dst$: for each $q$ in $h$}
		\STATE \rdwrite{q}{M[c,next[q]].msg}{m}
		\STATE \rdwrite{q}{M[c,next[q]].dst}{dst}
		\STATE \rdwrite{q}{M[c,next[q]].slot}{next}
		\STATE \rdwrite{q}{M[c,next[q]].tmp}{0}
		\STATE \rdwrite{q}{M[c,next[q]].stat}{\mcast}
%		\COMMENT{\textbf{Task 1}}
	\ENDINDENT
\vspace{1.0mm}


\STATE Server $p$ in group $g$ executes as follows:
\vspace{1.0mm}
\WHEN[\textbf{Task 1}]{$\exists c, k:\!M[c,k].stat =$ \mcast\ \band\ 
		$p \in Leader$}
	\STATE increment$(clock)$
	\INDENT{for each follower $q$ in $g$ \band\ each leader $q$ in $M[c,k].dst$}
		\STATE $i \leftarrow M[c,k].slot[q]$
		\STATE \rdwrite{q}{T[c,i].tmp[g]}{clock}
		\IF{write denied}
			\STATE request permission (Phase 1)
			\STATE end task
		\ENDIF
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 2}]{$\exists c, k\!:\!M[c,k].stat =$ \mcast\ \band \\
		\hspace{14mm} $T[c,k].tmp[g] \neq \perp$\hspace{-2mm}}
	\STATE update$(clock, T[c,k].tmp[g])$
%	\STATE{remove $(m, -, g)$ from $pending$}
%	\COMMENT{Needed???}
%	\STATE{include $(m,B[c,i].tmp[p], g)$ in $pending$}
	\INDENT{for each process $q$ in $M[c,k].dst$}
		\STATE $i \leftarrow M[c,k].slot[q]$
		\STATE \rdwrite{q}{M[c,i].ack[p]}{\texttt{ACK}}
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 3}]{$\exists c, k, h\!:\!M[c,k].stat =$ \mcast\ \band \\
		\hspace{14mm} $T[c,k].tmp[h] \neq \perp$ \band\ $h \neq g$ \hspace{-2mm}}
	\STATE update$(clock, T[c,k].tmp[h])$
%	\STATE{remove $(m,-,g)$ from $pending$}
%	\STATE{include $(m,B[c,i].tmp[p],g)$ in $pending$}
	\INDENT{for each follower $q$ in $g$}
		\STATE{$i \leftarrow M[c,k].slot[q]$}
%		\STATE{WRITE $B[c,i].tmp[p]$ in $@q \rightarrow B[c,j].tmp[p]$}
		\STATE \rdwrite{q}{T[c,i].tmp[h]}{T[c,k].tmp[h]}
%%%		\STATE \rdwrite{q}{T[c,i].tmp[h]}{T[c,k].tmp[h]}
%		\STATE{WRITE $B[c,i].rnd[p]$ in $@q \rightarrow B[c,j].rnd[p]$}		
		\INDENT{if write denied then}
			\STATE{request permission (Phase 1)}
			\STATE end task
		\ENDINDENT
	\ENDINDENT	
\ENDWHEN
\vspace{1.0mm}

\WHEN[\textbf{Task 4}]{$\exists c, k, h\!:\!M[c,k].stat =$ \mcast\ \band \\
	$\exists Q$ in $h$: for each $q$ in $Q$: $M[c,k].ack[q] = \ack$}
			\STATE $M[c,k].tmp \leftarrow$ \\
				\hspace{10mm} $max\{ M[c,k].tmp, M[c,k].tmp[Leader[h]] \}$
			\IF{for each group $h$ in $M[c,k].dst$: $\exists Q$ in $h$: \\
	\hfill for each $q$ in $Q$: $M[c,k].ack[q] = \ack$}
						\STATE $M[c,k].stat \leftarrow$ \ordered
			\ENDIF
%			\STATE{include $(m,t_{final})$ in $ordered$}
%			\STATE{remove $(m,-,-)$ from $pending$}		
\ENDWHEN
\vspace{1.0mm}


\WHEN[\textbf{Task 5}]{$\exists c, k\!:\!M[c,k].stat =$ \ordered\ \band \\
	\hspace{10mm} $\nexists d,l\!:\!M[d,l].stat \in \{ \ordered, \mcast \}$ \band\ \\
	\hspace{10mm} $M[d,l].tmp < M[c,k].tmp$}
		\STATE{deliver $m$}
		\STATE $M[c,k].stat \leftarrow$ \done
%		\STATE{remove $(m,-)$ from $ordered$}		
\ENDWHEN
\vspace{1.0mm}

\caption{Algorithm}
\label{alg:normal_case}
\end{distribalgo}
\end{algorithm}
