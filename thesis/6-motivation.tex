\chapter[Background and motivation]{Background and motivation}

\section{State-machine replication does not scale}
\label{sec:smr-does-not-scale}

Classical SMR does not scale: adding resources (e.g., replicas) will
not improve throughput. This happens for a couple reasons. First, the underlying
communication protocol needed to ensure ordered message delivery may not scale
itself (i.e., a communication bottleneck). Second, every command must be
executed sequentially by each replica (i.e., an execution bottleneck).

Several approaches have been proposed to address SMR's scalability limitations.
To cope with communication overhead, some proposals have suggested to spread the
load of ordering commands among multiple processes (e.g.,
\cite{Moraru:2013gw,Mencius,Marandi:2012hb}), as opposed to dedicating a single
process to determine the order of commands (e.g.,
\cite{Lamport:1998ea}).%\fxnote[draft]{remove inapplicable reference}

Two directions of research have been suggested to overcome execution
bottlenecks. One approach (scaling up) is to take advantage of multiple cores to
execute commands concurrently without sacrificing consistency
\cite{Kapritsos:2012um,Marandi:2014bj,Kotla:2004ep,Guo:2014jp}. Another approach
(scaling out) is to partition the service's state and replicate each partition
(e.g., \cite{Glendenning:2011kj,Marandi:2011dj}). In the following section, we
review Scalable State Machine Replication (\ssmr), a proposal in the second
category that is the basic for our work.

\section{Scaling state machine replication}

\subsection{Scalable state-machine replication}

\label{sec:ssmr}

In S-SMR~\cite{bezerra2014ssmr}, the service state \vvt\ is composed of $k$
partitions, in set $\Psi = \{\mathcal{V}_1, ..., \mathcal{V}_k\}$. Server group
$\ssm_i$ is assigned to partition $\mathcal{V}_i$. For brevity, we say that
server $s$ belongs to $\mathcal{V}_i$ meaning that $s \in \ssm_i$, and say
``multicast to $\mathcal{V}_i$'' meaning ``multicast to server group $\ssm_i$''.
S-SMR relies on an \emph{oracle}, which tells which partitions are accessed by
each command.%
\footnote{The oracle returns a set with the partitions accessed by the command,
but this set does not need to be minimal; it may contain all partitions in the
worst case, when the partitions accessed by the command cannot be determined
before the command is executed.}

To execute a command, the client multicasts the command to the appropriate
partitions, as determined by the oracle. Commands that access a single partition
are executed as in classical SMR: replicas of the concerned partition agree on
the execution order and each replica executes the command independently. In the
case of a multi-partition command, replicas of the involved partitions deliver
the command and then may need to exchange state in order to execute the command
since some partitions may not have all the values read in the command. This
mechanism allows commands to execute seamlessly despite the partitioned state.

S-SMR improves on classical SMR by allowing replicated systems to scale, while
ensuring linearizability. Under workloads with multi-partition commands,
however, it has limited performance, in terms of latency and throughput
scalability. Such decreased performance when executing multi-partition commands
is due to partitions (i) exchanging state variables and (ii) synchronizing by
exchanging signals.
%\ssmr\ performs better as the number of multi-partition commands decreases.

%One way to reduce the number of multi-partition commands is by dynamically
%changing the partitioning, putting variables that are usually accessed together
%in the same partition. However, the partitioning oracle of \ssmr\ relies on a
%static mapping of variables to partitions. One advantage of this implementation
%is that all clients and servers can have their own local oracle, which always
%returns a correct set of partitions for every query. Such a static mapping has
%the major limitation of not allowing the service to dynamically adapt to
%different access patterns.
